Поддержка prepared statements с переименованием - это ключевая особенность PgBouncer, которая решает проблему конфликта именованных prepared statements при переиспользовании соединений между разными клиентами.

## Проблема

Когда несколько клиентов используют один пул соединений:

```
Клиент А создает: PREPARE stmt1 AS SELECT * FROM users WHERE id = $1
Клиент Б получает то же соединение и создает: PREPARE stmt1 AS SELECT * FROM orders WHERE id = $1
→ ОШИБКА: prepared statement "stmt1" already exists
```

## Решение - переименование

PgBouncer перехватывает команды prepared statements и переименовывает их:

```
Клиент А отправляет: PREPARE stmt1 AS SELECT ...
→ PgBouncer переименовывает: PREPARE client_A_stmt1 AS SELECT ...

Клиент А отправляет: EXECUTE stmt1(123)
→ PgBouncer переводит: EXECUTE client_A_stmt1(123)

Клиент Б отправляет: PREPARE stmt1 AS SELECT ...
→ PgBouncer переименовывает: PREPARE client_B_stmt1 AS SELECT ...
```

Вот расширенная реализация с поддержкой prepared statements:Теперь код поддерживает prepared statements с переименованием! 

## Как это работает:

### 1. **Клиент отправляет команды с именем "my_query":**
```sql
PREPARE my_query AS SELECT $1 + $2
EXECUTE my_query(5, 10)
DEALLOCATE my_query
```

### 2. **PoolManager транслирует их:**
```sql
PREPARE pga_client_1_1 AS SELECT $1 + $2  -- переименовано
EXECUTE pga_client_1_1(5, 10)             -- переименовано
DEALLOCATE pga_client_1_1                 -- переименовано
```

### 3. **Другой клиент использует то же имя:**
```sql
-- Клиент 2 отправляет: PREPARE my_query AS SELECT $1 * $2
-- Транслируется в: PREPARE pga_client_2_1 AS SELECT $1 * $2
-- ✅ Нет конфликта!
```

## Ключевые компоненты:

- **PreparedStatementManager** - хранит маппинг имен для каждого клиента
- **PreparedStatementTranslator** - парсит и транслирует SQL команды
- **CleanupPreparedStatements** - очищает statements при возврате соединения в пул

## Это решает проблему:
- ✅ Разные клиенты могут использовать одинаковые имена prepared statements
- ✅ Statements автоматически очищаются при возврате соединения
- ✅ Поддерживается PREPARE, EXECUTE, DEALLOCATE
- ✅ Работает с параметрами и типами

Для полноценного прокси нужно добавить парсинг бинарного протокола PostgreSQL (Parse/Bind/Execute сообщения), но концепция та же

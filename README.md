# PgBouncer.NET

> **Тысячи клиентов → Сотня соединений к PostgreSQL**

Легковесный пул-менеджер соединений PostgreSQL на .NET 8.

---

## 🎯 Зачем это нужно?

### Проблема

```
У тебя есть веб-приложение на 10 серверов.
На каждом 200 потоков.
Итого: 2000 одновременных соединений к PostgreSQL.

PostgreSQL是一家：❌
- Каждое соединение = ~5-10 МБ памяти
- 2000 соединений = 10-20 ГБ RAM
- Переключение контекста между 2000 процессами = тормоза
- Postgres 配信过多崩溃 блядь
```

### Решение

```
PgBouncer.NET сидит между приложением и PostgreSQL:

Клиенты (2000 шт) → PgBouncer.NET → PostgreSQL (100 соединений)

Теперь:
- PostgreSQL держит только 100 реальных соединений
- Остальные 1900 ждут в пуле PgBouncer.NET
- PostgreSQL не дохнет = все работает быстро
- Ты сэкономил кучу денег на серверах 💰
```

---

## 🚀 Как это работает?

```
┌─────────────────────────────────────────────────────────────────┐
│                        Твое приложение                           │
│  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐   │
│  │App 1│  │App 2│  │App 3│  │ ... │  │App N│  │App N│  │App N│   │
│  └──┬───┘  └──┬───┘  └──┬───┘  └──┬───┘  └──┬───┘  └──┬───┘   │
└─────┼────────┼────────┼────────┼────────┼────────┼───────────┘
      │        │        │        │        │        │
      ▼        ▼        ▼        ▼        ▼        ▼
┌─────────────────────────────────────────────────────────────────┐
│                       PgBouncer.NET                             │
│                    (порт 6432)                                   │
│                                                                   │
│   ┌────────────────────  ПУЛ СОЕДИНЕНИЙ  ───────────────────┐   │
│   │                                                              │
│   │   2000 клиентских соединений   ⟷   100 серверных          │
│   │                                                              │
│   │   Когда клиент сделал запрос - подключил к PostgreSQL      │
│   │   Когда клиент закончил - вернул в пул                     │
│   │                                                              │
│   │   PostgreSQL думает что у него 100 соединений             │
│   │   А на самом деле обслуживает 2000 клиентов блядь!         │
│   │                                                              │
│   └────────────────────────────────────────────────────────────┘  │
│                                                                   │
│                    REST API мониторинг (порт 5080)                │
└─────────────────────────────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────────────────────────────┐
│                        PostgreSQL                                │
│                       (порт 5432)                                 │
│                   100 реальных соединений                         │
└─────────────────────────────────────────────────────────────────┘
```

---

## 📦 Из чего состоит?

```
pgbouncer.net/
├── src/
│   ├── PgBouncer.Core/           # Мозги: протокол PostgreSQL, пулы
│   ├── PgBouncer.Server/         # TCP сервер (порт 6432)
│   └── PgBouncer.Dashboard.Api/  # REST API для мониторинга (5080)
└── tests/
    └── PgBouncer.LoadTester/     # Нагрузочный тестер
```

---

## ⚙️ Установка и запуск

### 1. Настройка

Открой `src/PgBouncer.Server/appsettings.json`:

```json
{
  "ListenPort": 6432,          // На этом порту клиенты коннектятся к пулеру
  "DashboardPort": 5080,       // Мониторинг на этом порту

  "Backend": {
    "Host": "localhost",       // Где находится PostgreSQL
    "Port": 5432,              // Порт PostgreSQL
    "AdminUser": "postgres",   // Системный пользователь
    "AdminPassword": "password" // Пароль (для создания пулов)
  },

  "Pool": {
    "DefaultSize": 20,         // Начальный размер пула
    "MaxSize": 100,            // Макс соединений на одну БД
    "MaxTotalConnections": 2000, // Общий лимит
    "Mode": "Transaction"      // Режим (см. ниже)
  }
}
```

### 2. Запуск

```powershell
# Запуск пулера
cd src\PgBouncer.Server
dotnet run

# Запуск дашборда (в другом окне)
cd src\PgBouncer.Dashboard.Api
dotnet run
```

### 3. Подключи приложение

**Было (коннект прямо к PostgreSQL):**
```csharp
Host=192.168.1.100;Port=5432;Database=mydb;Username=user;Password=pass
```

**Стало (коннект через пулер):**
```csharp
Host=localhost;Port=6432;Database=mydb;Username=user;Password=pass
                    ↑↑
              Порт пулера вместо PostgreSQL
```

Всё! Теперь твое приложение ходит через пулер.

---

## 🎮 Режимы пулинга

### Session Mode (по умолчанию в PostgreSQL)

```
Клиент подключился → соединение закреплено за ним
Клиент сделал 100 запросов → всё через одно соединение
Клиент отключился → соединение вернулось в пул

+ Сохраняет temporary таблицы, Prepared statements
- Не масштабируется хорошо
```

### Transaction Mode (рекомендуется) 🌟

```
Клиент начал транзакцию → взял соединение из пула
Клиент сделал COMMIT → соединение вернулось в пул
Следующая транзакция → может взять другое соединение

+ Максимальное масштабирование
+ 2000 клиентов через 100 соединений
- Не работает с temporary таблицами между транзакциями
```

### Statement Mode

```
Каждый SQL statement = новое соединение из пула

+ Максимальная concurrency
- Минимальная совместимость
```

---

## 📊 Мониторинг

### REST API

```powershell
# Общая статистика
curl http://localhost:5080/api/stats/summary

# Статистика всех пулов
curl http://localhost:5080/api/stats

# Конкретный пул
curl http://localhost:5080/api/stats/mydb/user1
```

### Пример ответа

```json
{
  "totalPools": 3,
  "totalConnections": 45,
  "activeConnections": 12,
  "idleConnections": 33,
  "pools": [
    {
      "database": "mydb",
      "username": "user1",
      "active": 5,
      "idle": 15,
      "total": 20
    }
  ]
}
```

### Swagger UI

Открой в браузере: `http://localhost:5080/swagger`

---

## 🧪 Нагрузочное тестирование

### Запуск теста

```powershell
cd tests\PgBouncer.LoadTester

# Базовый тест
dotnet run -- --connections 100 --duration 60

# Hardctest
dotnet run -- --connections 500 --instances 10 --pattern mixed --duration 120
```

### Паттерны нагрузки

| Паттерн      | Описание                                 |
| ------------ | ---------------------------------------- |
| `rapid`      | Много быстрых запросов (10ms задержка)   |
| `idle`       | Редкие запросы, много idle (5s задержка) |
| `mixed`      | Смешанная нагрузка (100-1000ms)          |
| `burst`      | Периодические всплески                   |
| `transaction`| Длинные транзакции                       |

### Результат

```
╔══════════════════════════════════════════════════════════╗
║                  ИТОГОВАЯ СТАТИСТИКА                     ║
╚══════════════════════════════════════════════════════════╝

Длительность:        60.12с
Всего запросов:      125,430
Запросов/сек:        2,086
Ошибок:              0 (0.00%)

Latency:
  Средняя:           12.45 мс
  p50:               8.32 мс
  p95:               28.91 мс
  p99:               45.67 мс
```

---

## 🏆 Почему PgBouncer.NET?

### Vs Оригинальный PgBouncer (C)

|                    | PgBouncer (C) | PgBouncer.NET |
| ------------------ | ------------- | ------------- |
| Платформа          | Linux         | **Windows** 🪟 |
| Настройка          | ini файл      | **JSON + .NET** |
| Мониторинг         | консоль       | **REST API + Swagger** |
| Интеграция         | отдельный     | **в .NET экосистему** |
| Стек технологий    | C + libevent  | **C# + async/await** |

### Vs Апп-level pooling (Npgsql)

```
Npgsql встроенный pooling:
- Каждый app сервер свой пул
- 10 app серверов = 10 независимых пулов
- Не контролируется централизованно

PgBouncer.NET:
- Один пул на все приложения
- Централизованный контроль
- Один мониторинг для всех
```

---

## 🛠️ Продвинутая настройка

### PostgreSQL

```ini
# postgresql.conf
max_connections = 500  # Достаточно для пулера
shared_buffers = 4GB   # Увеличь если есть память
```

### PgBouncer.NET

```json
{
  "Pool": {
    "Mode": "Transaction",
    "DefaultSize": 20,
    "MinSize": 5,           // Минимальный размер пула
    "MaxSize": 100,         // Макс на БД/пользователя
    "MaxTotalConnections": 2000, // Общий лимит
    "IdleTimeout": 300,     // Секунды перед закрытием idle
    "ConnectionTimeout": 30 // Таймаут подключения к PG
  }
}
```

---

## 📈 Когда использовать?

### ✅ Используй когда:

- У тебя больше 100 одновременных соединений к PostgreSQL
- Множество app серверов подключаются к одной БД
- PostgreSQL тормозит или падает от количества connections
- Хочешь централизованный мониторинг всех коннектов
- Работаешь на Windows и не хочешь заморачиваться с Linux

### ❌ Не используй когда:

- У тебя < 50 одновременных соединений (overkill)
- Нужны temporary таблицы между транзакциями (используй Session mode)
- Используешь prepared statements с именами (пока не поддерживается)

---

## 🔜 TODO

- [ ] MD5/SCRAM-SHA-256 аутентификация (сейчас только passthrough)
- [ ] Prepared statements с переименованием
- [ ] Web dashboard (Blazor)
- [ ] Windows Service
- [ ] Hot-reload конфигурации
- [ ] Prometheus metrics

---

## 📄 Лицензия

MIT

---

## 🤝 Вклад

PR welcome! Просто fork, коммить и открывай pull request.

---

**Сделано с любовью и .NET 8**
